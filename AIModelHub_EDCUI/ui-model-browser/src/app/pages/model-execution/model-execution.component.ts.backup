import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { 
  ModelExecutionService, 
  ExecutableAsset,
  ModelExecutionResponse 
} from '../../shared/services/model-execution.service';
import { AssetService } from '../../shared/services/asset.service';

@Component({
  selector: 'app-model-execution',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './model-execution.component.html',
  styleUrls: ['./model-execution.component.scss']
})
export class ModelExecutionComponent implements OnInit {
  private readonly executionService = inject(ModelExecutionService);
  private readonly assetService = inject(AssetService);
  private readonly route = inject(ActivatedRoute);
  private readonly router = inject(Router);

  // State
  loading = false;
  executing = false;
  loadingAssets = false;
  
  // Data
  executableAssets: ExecutableAsset[] = [];
  selectedAsset: ExecutableAsset | null = null;
  
  // Input
  inputJson = '';
  inputError = '';
  inputMode: 'form' | 'json' = 'form'; // form or json mode
  formFields: Map<string, any> = new Map(); // Dynamic form fields
  inputSchema: any = null; // Schema from model metadata
  
  // Output
  executionResult: ModelExecutionResponse | null = null;
  executionHistory: any[] = [];
  
  // UI
  showHistory = false;
  activeTab: 'input' | 'output' | 'history' = 'input';

  ngOnInit(): void {
    // Check if asset ID was passed as query parameter
    const assetId = this.route.snapshot.queryParamMap.get('assetId');
    
    if (assetId) {
      this.loadAssetForExecution(assetId);
    } else {
      this.loadExecutableAssets();
    }
  }

  /**
   * Load all executable assets
   */
  loadExecutableAssets(): void {
    this.loadingAssets = true;
    
    this.executionService.getExecutableAssets().subscribe({
      next: (response) => {
        this.executableAssets = response.assets;
        this.loadingAssets = false;
        
        if (this.executableAssets.length === 0) {
          console.warn('No executable assets found');
        }
      },
      error: (error) => {
        console.error('Error loading executable assets:', error);
        this.loadingAssets = false;
      }
    });
  }

  /**
   * Load a specific asset for execution
   */
  loadAssetForExecution(assetId: string): void {
    this.loading = true;
    
    this.executionService.checkAssetExecutable(assetId).subscribe({
      next: (info) => {
        if (info.isExecutable) {
          // Load full asset details
          this.assetService.getAsset(assetId).subscribe({
            next: (asset: any) => {
              // Transform to ExecutableAsset
              this.selectedAsset = {
                id: assetId,
                name: info.assetName,
                version: '1.0',
                asset_type: 'ExecutableMLModel',
                owner: '',
                execution_endpoint: info.executionEndpoint || '',
                execution_method: info.executionMethod || 'POST',
                execution_timeout: info.executionTimeout || 30000,
                input_features: info.inputSchema,
                input_features: info.inputSchema,
                created_at: new Date().toISOString()
              };
              
              this.prepareInputTemplate();
              this.loadExecutionHistory();
              this.loading = false;
            },
            error: (error) => {
              console.error('Error loading asset:', error);
              this.loading = false;
            }
          });
        } else {
          console.error('Asset is not executable');
          this.loading = false;
          this.router.navigate(['/catalog']);
        }
      },
      error: (error) => {
        console.error('Error checking asset:', error);
        this.loading = false;
        this.router.navigate(['/catalog']);
      }
    });
  }

  /**
   * Handle asset selection from dropdown
   */
  onAssetSelect(event: Event): void {
    const selectElement = event.target as HTMLSelectElement;
    const assetId = selectElement.value;
    
    if (!assetId) {
      this.selectedAsset = null;
      this.inputJson = '';
      return;
    }
    
    this.selectedAsset = this.executableAssets.find(a => a.id === assetId) || null;
    
    if (this.selectedAsset) {
      this.prepareInputTemplate();
      this.loadExecutionHistory();
    }
  }

  /**
   * Prepare input template based on model's input schema
   */
  prepareInputTemplate(): void {
    if (!this.selectedAsset || !this.selectedAsset.input_features) {
      this.inputJson = JSON.stringify({ input: "data" }, null, 2);
      return;
    }

    try {
      const inputFeatures = this.selectedAsset.input_features;
      
      // If input_features has a schema, use it as template
      if (inputFeatures.schema) {
        const template: any = {};
        for (const [key, type] of Object.entries(inputFeatures.schema)) {
          template[key] = type === 'float' ? 0.0 : type === 'int' ? 0 : '';
        }
        this.inputJson = JSON.stringify(template, null, 2);
      } else if (inputFeatures.features) {
        // Create template from feature names
        const template: any = {};
        inputFeatures.features.forEach((feature: string) => {
          template[feature] = 0.0;
        });
        this.inputJson = JSON.stringify(template, null, 2);
      } else {
        this.inputJson = JSON.stringify({ input: "data" }, null, 2);
      }
    } catch (error) {
      console.error('Error preparing input template:', error);
      this.inputJson = JSON.stringify({ input: "data" }, null, 2);
    }
  }

  /**
   * Validate JSON input
   */
  validateInput(): boolean {
    this.inputError = '';
    
    if (!this.inputJson.trim()) {
      this.inputError = 'Input cannot be empty';
      return false;
    }
    
    try {
      JSON.parse(this.inputJson);
      return true;
    } catch (error) {
      this.inputError = 'Invalid JSON format';
      return false;
    }
  }

  /**
   * Execute the model
   */
  executeModel(): void {
    if (!this.selectedAsset) {
      alert('Please select a model first');
      return;
    }
    
    if (!this.validateInput()) {
      return;
    }
    
    this.executing = true;
    this.executionResult = null;
    this.activeTab = 'output';
    
    const inputData = JSON.parse(this.inputJson);
    
    this.executionService.executeModel({
      assetId: this.selectedAsset.id,
      input: inputData
    }).subscribe({
      next: (result) => {
        this.executionResult = result;
        this.executing = false;
        
        // Reload history
        this.loadExecutionHistory();
      },
      error: (error) => {
        console.error('Execution error:', error);
        this.executionResult = {
          executionId: 'error',
          status: 'error',
          assetId: this.selectedAsset!.id,
          error: {
            message: error.error?.message || error.message || 'Unknown error',
            code: 'EXECUTION_FAILED',
            details: error
          },
          timestamp: new Date().toISOString()
        };
        this.executing = false;
      }
    });
  }

  /**
   * Load execution history for selected asset
   */
  loadExecutionHistory(): void {
    if (!this.selectedAsset) return;
    
    this.executionService.getExecutionHistory(this.selectedAsset.id, 10).subscribe({
      next: (response) => {
        this.executionHistory = response.executions;
      },
      error: (error) => {
        console.error('Error loading execution history:', error);
      }
    });
  }

  /**
   * Switch to history tab
   */
  viewHistory(): void {
    this.activeTab = 'history';
    this.loadExecutionHistory();
  }

  /**
   * Get status badge class
   */
  getStatusClass(status: string): string {
    switch (status) {
      case 'success': return 'badge-success';
      case 'error': return 'badge-error';
      case 'timeout': return 'badge-warning';
      case 'running': return 'badge-info';
      case 'pending': return 'badge-secondary';
      default: return 'badge-secondary';
    }
  }

  /**
   * Format execution time
   */
  formatExecutionTime(ms?: number): string {
    if (!ms) return 'N/A';
    if (ms < 1000) return `${ms}ms`;
    return `${(ms / 1000).toFixed(2)}s`;
  }

  /**
   * Navigate back to catalog
   */
  goBack(): void {
    this.router.navigate(['/catalog']);
  }
}
